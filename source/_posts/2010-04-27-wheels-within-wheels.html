---
layout: post
title: "Wheels within wheels"
date: 2010-04-27
comments: false
---

<div class='post'>
Software is best built incrementally. I hope everyone agrees with that. There's quite a bit of disagreement as to what "incrementally", of course, but it seems to have something to do with <i>iterations</i>.<br /><br />No one really agrees on what an iteration is either. There are a lot of fancy metaphors and abstract phrases that get used to describe the various bits of what people think an iteration is: customers tell "stories" that engineers then "estimate"; programmers "sprint" like children at an athletics carnival; they "release" software as if it were an insufficiently randy panda; deliverables get delivered.<br /><br />When one washes all of the metaphors and best little practices away, what's left is this: build a little bit of software; evaluate it. Ideally, the software is evaluated by someone who stands to benefit directly from using it.<br /><br />I'm not sure there's much more to recent software methodologies than that. Perhaps we can explore it more in the comments.<br /><br />This combination of increments and iterations spirals toward the final product, which is generally what you have left when the money runs out. Alas, if only we could draw a picture of the process with a simple spiral!  When I think of it, I fall prey to a rare attack of envy toward students of <a href="http://en.wikipedia.org/wiki/Hermeneutics">hermeneutics</a>.<br /><br />The process involves spirals within spirals, cycles made up of cycles. Going<br />inwards from the greatest wheel to the smallest, the Launchpad project has:<br /><dl><dt>planning cycles</dt><br /><dd>When we plan the major features and general direction of Launchpad. <a href="https://dev.launchpad.net/RoadMap">Road map</a> sort of<br />stuff. Approximately six months.</dd><br /><dt>feature cycles</dt><br /><dd>The repeated process of beginning a feature, developing it, releasing it,<br />fixing it, then stopping. Varies in cycle time, but usually one to three<br />months.</dd><br /><dt>release cycles</dt><br /><dd>We release whatever is in <a href="https://dev.launchpad.net/Trunk">trunk</a> each month</dd><br /><dt>branch cycles</dt><br /><dd>Branch from trunk, hack on it, push it up, get it reviewed, land it, wait<br />until it passes the test suite, check that the changes worked. Two or three<br />days.</dd><br /><dt>experiment cycles</dt><br /><dd>A developer is working on a thing and wants to actually see how it works<br />in the running code. They write many tests and a fair bit of code and then<br />fire up a development instance of Launchpad and see how it looks.</dd><br /><dt>TDD cycles</dt><br /><dd>Write a failing test. Run the tests (a subset of the whole suite). Make<br />the test pass. Run the tests. Refactor. Run the tests. Probably about<br />half-an-hour?</dd></dl>Different projects surely have different kinds of cycles. Most projects probably have a subset of the ones above. In any case, thinking in terms of nested cycles is a good way of analyzing ones development process.<br /><br />Each of these cycles has its own overhead and its own waste. One cycle being particularly slow has a different effect to another cycle being slow. For example, I contend that the slow branch cycle makes it less likely that trivial bugs get fixed.<br /><br />Lean advocates would tell me not to think this way. They would have me unroll these cycles and lay them out on a line beginning with someone wanting something and ending with that want satisfied. They would have me draw a "value stream map".<br /><br />Bollocks to them. At least on Launchpad, we should optimize the innermost loops first.<br /><br />Have I missed some kinds of cycles? Can you think of a better name than "experiment cycle"? Is there prior literature I should read? Are you going to apply these ideas to your project?</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>jml</div>
<div class='content'>
Dean, I&#39;ll do what I can. The short answer is that I think there&#39;s a lot of waste happening at a much finer level of granularity than we track with our Kanban board.<br /><br />Perhaps I can convince Francis (our local Kanban advocate) to say something.</div>
</div>
<div class='comment'>
<div class='author'>jml</div>
<div class='content'>
Robert, I agree that taking an &quot;optimize the inner loop&quot; approach would probably yield similar results to a value-stream-driven &quot;optimize the time between request and fulfilment&quot;.<br /><br />However, I&#39;m not entirely sure it&#39;s guaranteed, and the Poppendieck&#39;s repeatedly advocate &quot;seeing the whole&quot; and optimizing for it, and frequently warn against micro-optimizing.<br /><br />By dividing things up into loops and cycles, I am explicitly ignoring their advice. I can imagine that, actually, they&#39;d approve of me doing so.</div>
</div>
<div class='comment'>
<div class='author'>jml</div>
<div class='content'>
Robert Collins tried to comment on this post, but ran into technical difficulties. He emailed me his comment, which I&#39;m pasting here:<br /><br />I don&#39;t think Lean advocates would unroll everything - I wouldn&#39;t, and I think I&#39;m a Lean advocate. I&#39;d treat the users request stalling at the outside edge of each cycle, before it passes into an inner cycle,<br />as a stall, and I&#39;d try to break each cycle into little boxes so that I could talk sensibly about how much time e.g. running tests. I naively expect to see a similar conclusion if modelled this way - inner loops that don&#39;t work well consume most of the duration of the vsm.</div>
</div>
<div class='comment'>
<div class='author'>Dean Goodmanson</div>
<div class='content'>
Looking forward to a follow-up bloag and hearing how this relates to the use of a Kanban board/tool.<br /><br />https://dev.launchpad.net/Kanban</div>
</div>
<div class='comment'>
<div class='author'>jkakar</div>
<div class='content'>
We pretty much have the same set of cycles on the Landscape project, with some having similar timelines.  For example our planning cycle is 6 months, similar to Launchpad.  I think our TDD cycle has a much faster turn-around time than 30 minutes.  It&#39;s more like 1 or 2, which is slower than I&#39;d like.<br /><br />Something I&#39;ve been thinking about recently is a 2-3 year roadmap, a set of high-level themes for the project that we use to guide our choices when we make decisions regarding our planning cycle.  My first thought was that this was an outer ring that you didn&#39;t include in your post, but I don&#39;t think that&#39;s quite right.  It&#39;s more like the set of forces that affect the direction in which the wheel is rolling.<br /><br />Also, I&#39;ve been meaning to write this blog post for more than two years, but have procrastinated and done nothing about this desire.  Thanks for beating me to it and describing the pieces so clearly.</div>
</div>
</div>
