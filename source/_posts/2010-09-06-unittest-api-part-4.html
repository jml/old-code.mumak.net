---
layout: post
title: "unittest API, part 4"
date: 2010-09-06
comments: false
---

<div class='post'>
As I said at the very beginning, unittest has an API with lots of interfaces. You can read about the interfaces for test frameworks in <a href="http://code.mumak.net/2010/07/unittest-api-part-1.html">part 1</a>, <a href="http://code.mumak.net/2010/07/unittest-api-part-2.html">part 2</a> and <a href="http://code.mumak.net/2010/08/unittest-part-3.html">part 3</a> of this series. This post is about the interface for test authors.<br /><br />If the other posts are fresh in your mind, it's important to remember that this post is focused on the standard implementation of <code>TestCase</code>. After all, it's that implementation which creates the interface for test authors. There are other implementations (e.g. <code>FunctionTestCase</code> and <code>DocTestCase</code>) which provide completely different interfaces for test authors, and one could write one's own implementation that provided something else entirely.<br /><div><br /></div><div><b>Subclassing <code>TestCase</code></b></div><div><br /></div><div>Almost all of the time that you want to write tests, you subclass unittest.TestCase. It's not the only way to write unit tests with unittest, but it's rather handy, particularly since the default test loader looks for subclasses of <code>TestCase</code>.<br /><br />This is going to be much easier for all of us if I work from an example.</div><br /><pre>class SomeTests(TestCase):<br />  def setUp(self):<br />    print "setUp"<br />  def tearDown(self):<br />    print "tearDown"<br />  def test_a(self):<br />    print "a"<br />  def test_b(self):<br />    print "b"<br /></pre><br /><div>The test loader will make something that looks like <code>unittest.TestSuite([SomeTests("test_a"), SomeTests("test_b")])</code>. That is, it constructs an instance of <code>SomeTests</code> for each method beginning with "test".<br /><br />The tests will only be run when <code>TestCase.run(result)</code> is called. The tests do not get access to the result object, instead the run() method mediates between the tests and the result.<br /><br />The default <code>TestCase.run(result)</code> method will run <code>setUp()</code>, then the test method given in the constructor (e.g. <code>test_a</code>), then <code>tearDown()</code>.<br /><br />If <code>setUp()</code> raises any exception, <code>tearDown()</code> will not be run. The result object will have <code>addError</code> called on it with the test and the error.<br /><br />If the test method raises an exception, one of two things can happen. If the exception is an instance of <code>self.failureException</code>, then <code>result.addFailure(test, exc_info)</code> is called, where test is the <code>TestCase</code> instance and <code>exc_info</code> is the <code>sys.exc_info()</code> tuple. Otherwise, <code>result.addError(test, exc_info)</code> is called. In either case, <code>tearDown()</code> is then run.<br /><br />If <code>tearDown()</code> raises an exception, <code>result.addError(test, exc_info)</code> is called.<br /><br />There are lots of built-in assertion methods on <code>unittest.TestCase</code>. These all raise <code>self.failureException</code> if their assertion fails. These are part of the interface for test authors, but they are already very well documented. Just note that if you write your own, remember to raise <code>self.failureException</code>, or better yet call <code>self.fail()</code>, rather than raising <code>AssertionError</code> or something crazy like that.<br /><br />That's pretty much it.<br /><br />Of course, you could write your own object that implemented <b><code>ITest</code></b> and <b><code>ITestCase</code></b>, and use your own test loader, and then you don't have to care about anything in this post. But don't do that. Better to subclass <code>unittest.TestCase</code>.<br /><br />As always, feedback welcome.</div></div>
